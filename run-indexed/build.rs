use std::{
    env,
    error::Error,
    fs::File,
    io::{BufWriter, Write},
    path::PathBuf,
};

const MAX_CODEPOINT: u32 = 0x10ffff;
const START_CODEPOINT: u32 = 0x80;
const BYTES_PER_LINE: usize = 12;
const INDEX_BYTES_PER_LINE: usize = 16;
const SHIFT: u32 = 10;

fn main() -> Result<(), Box<dyn Error>> {
    let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR")?);
    let derived = manifest_dir.join("../DerivedCoreProperties.txt");
    println!("cargo:rerun-if-changed={}", derived.display());
    println!("cargo:rerun-if-changed=build.rs");

    let file = File::open(&derived)?;
    let parsed = unicode_id_trie_rle_derived_core_properties::parse(file)?;

    let mut table = vec![0u8; (MAX_CODEPOINT + 1) as usize];
    for (ch, props) in parsed {
        if (ch as u32) > MAX_CODEPOINT {
            continue;
        }

        let mut bits = 0u8;
        for prop in props {
            if prop.contains("XID_Start") {
                bits |= 1;
            }
            if prop.contains("XID_Continue") {
                bits |= 2;
            }
        }
        table[ch as usize] = bits;
    }

    let end_cp = MAX_CODEPOINT + 1; // sentinel run start
    let mut runs = Vec::with_capacity(1024);
    let mut run_start = START_CODEPOINT;
    let mut current = table[run_start as usize];
    for cp in (START_CODEPOINT + 1)..=end_cp {
        let value = if cp <= MAX_CODEPOINT {
            table[cp as usize]
        } else {
            0
        };

        if value != current {
            runs.push((run_start, current));
            run_start = cp;
            current = value;
        }
    }
    runs.push((run_start, current));
    if runs.last().map_or(true, |(s, _)| *s != end_cp) {
        runs.push((end_cp, 0));
    }

    assert!(
        runs.len() < u16::MAX as usize,
        "run table too large for u16 index: {}",
        runs.len()
    );

    let block_count = (MAX_CODEPOINT >> SHIFT) + 1;
    let mut block_index = vec![0u16; block_count as usize];
    let mut run_idx = 0usize;
    for block in 0..block_count {
        let block_start = block << SHIFT;
        while run_idx + 1 < runs.len() && runs[run_idx + 1].0 <= block_start {
            run_idx += 1;
        }
        block_index[block as usize] = run_idx as u16;
    }

    let bits_per_index = {
        let max_val = runs.len().saturating_sub(1) as u32;
        let bits = 32 - max_val.leading_zeros();
        u8::try_from(bits.max(1)).expect("bits per index fits in u8")
    };
    let mut index_bytes = Vec::with_capacity(
        ((block_index.len() * bits_per_index as usize) + 7) / 8,
    );
    let mut acc: u32 = 0;
    let mut acc_bits: u8 = 0;
    for &val in &block_index {
        let v = val as u32;
        acc |= v << acc_bits;
        acc_bits += bits_per_index;
        while acc_bits >= 8 {
            index_bytes.push((acc & 0xff) as u8);
            acc >>= 8;
            acc_bits -= 8;
        }
    }
    if acc_bits > 0 {
        index_bytes.push(acc as u8);
    }
    while index_bytes.len() % 4 != 0 {
        index_bytes.push(0);
    }
    index_bytes.extend_from_slice(&[0, 0, 0]); // pad for u32 loads near the end

    let out_dir = PathBuf::from(env::var("OUT_DIR")?);
    let out_path = out_dir.join("table.rs");
    let out_file = File::create(&out_path)?;
    let mut writer = BufWriter::new(out_file);

    writeln!(writer, "// Code generated by build.rs; DO NOT EDIT.")?;
    writeln!(writer, "pub(crate) const SHIFT: u32 = {SHIFT};")?;
    writeln!(
        writer,
        "pub(crate) const BLOCK_COUNT: usize = {};",
        block_count as usize
    )?;
    writeln!(
        writer,
        "pub(crate) const INDEX_BITS: u32 = {bits_per_index};"
    )?;
    writeln!(
        writer,
        "pub(crate) static RUNS: [u8; {}] = [",
        runs.len() * 3
    )?;
    for (idx, (start, value)) in runs.iter().enumerate() {
        let offset = idx * 3;
        let b0 = (start & 0xff) as u8;
        let b1 = ((start >> 8) & 0xff) as u8;
        let b2 = ((start >> 16) & 0x1f) as u8 | (value & 3) << 5;

        if offset % BYTES_PER_LINE == 0 {
            write!(writer, "\t")?;
        }
        write!(writer, "0x{b0:02x}, 0x{b1:02x}, 0x{b2:02x},")?;
        if (offset + 3) % BYTES_PER_LINE == 0 {
            writeln!(writer)?;
        } else {
            write!(writer, " ")?;
        }
    }
    if (runs.len() * 3) % BYTES_PER_LINE != 0 {
        writeln!(writer)?;
    }
    writeln!(writer, "];")?;

    writeln!(
        writer,
        "pub(crate) static BLOCK_INDEX: [u8; {}] = [",
        index_bytes.len()
    )?;
    for (idx, entry) in index_bytes.iter().enumerate() {
        if idx % INDEX_BYTES_PER_LINE == 0 {
            write!(writer, "\t")?;
        }
        write!(writer, "0x{entry:02x},")?;
        if idx % INDEX_BYTES_PER_LINE == INDEX_BYTES_PER_LINE - 1
            || idx + 1 == index_bytes.len()
        {
            writeln!(writer)?;
        } else {
            write!(writer, " ")?;
        }
    }
    writeln!(writer, "];")?;
    writer.flush()?;

    Ok(())
}
